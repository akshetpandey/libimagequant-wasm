<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>libimagequant WASM Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .panel {
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 5px;
        }
        
        canvas {
            max-width: 100%;
            border: 1px solid #ccc;
        }
        
        .controls {
            margin: 10px 0;
        }
        
        .controls label {
            display: block;
            margin: 5px 0;
        }
        
        .controls input, .controls select {
            width: 100%;
            margin: 2px 0;
        }
        
        button {
            background: #007cba;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 3px;
            cursor: pointer;
            margin: 5px;
        }
        
        button:hover {
            background: #005a87;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .info {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 3px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 12px;
        }
        
        .error {
            background: #ffebee;
            color: #c62828;
            padding: 10px;
            border-radius: 3px;
            margin: 10px 0;
        }
        
        .success {
            background: #e8f5e8;
            color: #2e7d32;
            padding: 10px;
            border-radius: 3px;
            margin: 10px 0;
        }
        
        .palette {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(20px, 1fr));
            gap: 2px;
            margin: 10px 0;
        }
        
        .color-swatch {
            width: 20px;
            height: 20px;
            border: 1px solid #000;
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <h1>libimagequant WASM Test</h1>
    
    <div class="panel">
        <h3>Load Image</h3>
        <input type="file" id="imageInput" accept="image/*">
        <button onclick="loadSampleImage()">Load Sample Image</button>
    </div>

    <div class="container">
        <div class="panel">
            <h3>Original Image</h3>
            <canvas id="originalCanvas"></canvas>
            <div id="originalInfo" class="info"></div>
        </div>
        
        <div class="panel">
            <h3>Quantized Image</h3>
            <canvas id="quantizedCanvas"></canvas>
            <div id="quantizedInfo" class="info"></div>
            
            <h4>Color Palette</h4>
            <div id="palette" class="palette"></div>
        </div>
    </div>

    <div class="panel">
        <h3>Quantization Settings</h3>
        <div class="controls">
            <label>
                Speed (1-10, lower = better quality):
                <input type="range" id="speed" min="1" max="10" value="3">
                <span id="speedValue">3</span>
            </label>
            
            <label>
                Quality Min (0-100):
                <input type="range" id="qualityMin" min="0" max="100" value="70">
                <span id="qualityMinValue">70</span>
            </label>
            
            <label>
                Quality Target (0-100):
                <input type="range" id="qualityTarget" min="0" max="100" value="100">
                <span id="qualityTargetValue">100</span>
            </label>
            
            <label>
                Max Colors (2-256):
                <input type="range" id="maxColors" min="2" max="256" value="256">
                <span id="maxColorsValue">256</span>
            </label>
            
            <label>
                Dithering (0.0-1.0):
                <input type="range" id="dithering" min="0" max="100" value="100">
                <span id="ditheringValue">1.0</span>
            </label>
        </div>
        
        <button id="quantizeBtn" onclick="quantizeImage()" disabled>Quantize Image</button>
        <button onclick="downloadQuantized()" id="downloadBtn" disabled>Download Result</button>
    </div>

    <div id="messages"></div>

    <script type="module">
        import LibImageQuant from '../dist/index.mjs';

        let quantizer = null;
        let originalImageData = null;
        let lastResult = null;

        // Initialize quantizer
        async function initQuantizer() {
            try {
                showMessage('Initializing WASM module...', 'info');
                quantizer = new LibImageQuant({
                    workerUrl: '../dist/worker.mjs'
                });
                await quantizer.initPromise;
                showMessage('WASM module initialized successfully!', 'success');
                return true;
            } catch (error) {
                showMessage(`Failed to initialize WASM module: ${error.message}`, 'error');
                return false;
            }
        }

        // Update slider values
        function updateSliderValues() {
            document.getElementById('speedValue').textContent = document.getElementById('speed').value;
            document.getElementById('qualityMinValue').textContent = document.getElementById('qualityMin').value;
            document.getElementById('qualityTargetValue').textContent = document.getElementById('qualityTarget').value;
            document.getElementById('maxColorsValue').textContent = document.getElementById('maxColors').value;
            document.getElementById('ditheringValue').textContent = (document.getElementById('dithering').value / 100).toFixed(2);
        }

        // Add event listeners for sliders
        ['speed', 'qualityMin', 'qualityTarget', 'maxColors', 'dithering'].forEach(id => {
            document.getElementById(id).addEventListener('input', updateSliderValues);
        });

        // File input handler
        document.getElementById('imageInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                loadImageFromFile(file);
            }
        });

        function loadImageFromFile(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = async function() {
                    await drawImageToCanvas(img, 'originalCanvas');
                    document.getElementById('quantizeBtn').disabled = false;
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        window.loadSampleImage = async function() {
            // Create a sample gradient image
            const canvas = document.getElementById('originalCanvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = 200;
            canvas.height = 200;
            
            // Create a colorful gradient
            for (let x = 0; x < canvas.width; x++) {
                for (let y = 0; y < canvas.height; y++) {
                    const r = Math.floor((x / canvas.width) * 255);
                    const g = Math.floor((y / canvas.height) * 255);
                    const b = Math.floor(((x + y) / (canvas.width + canvas.height)) * 255);
                    
                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    ctx.fillRect(x, y, 1, 1);
                }
            }
            
            await updateOriginalInfo();
            document.getElementById('quantizeBtn').disabled = false;
        };

        async function drawImageToCanvas(img, canvasId) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            
            // Scale down large images
            const maxSize = 400;
            let { width, height } = img;
            
            if (width > maxSize || height > maxSize) {
                const ratio = Math.min(maxSize / width, maxSize / height);
                width *= ratio;
                height *= ratio;
            }
            
            canvas.width = width;
            canvas.height = height;
            
            ctx.drawImage(img, 0, 0, width, height);
            await updateOriginalInfo();
        }

        // Function to estimate PNG size from canvas
        function estimatePngSize(canvas) {
            return new Promise((resolve) => {
                canvas.toBlob((blob) => {
                    resolve(blob.size);
                }, 'image/png');
            });
        }

        async function updateOriginalInfo() {
            const canvas = document.getElementById('originalCanvas');
            const ctx = canvas.getContext('2d');
            originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            const pixels = canvas.width * canvas.height;
            const rawKb = Math.round((originalImageData.data.length / 1024) * 100) / 100;
            
            // Calculate estimated PNG size
            const pngSizeBytes = await estimatePngSize(canvas);
            const pngKb = Math.round((pngSizeBytes / 1024) * 100) / 100;
            
            document.getElementById('originalInfo').innerHTML = `
                Dimensions: ${canvas.width} × ${canvas.height}<br>
                Pixels: ${pixels.toLocaleString()}<br>
                Raw RGBA: ${rawKb} KB<br>
                PNG encoded: ${pngKb} KB
            `;
        }

        window.quantizeImage = async function() {
            if (!originalImageData || !quantizer) {
                showMessage('Please load an image and wait for WASM initialization', 'error');
                return;
            }

            const btn = document.getElementById('quantizeBtn');
            btn.disabled = true;
            btn.textContent = 'Quantizing...';

            try {
                const options = {
                    speed: parseInt(document.getElementById('speed').value),
                    quality: {
                        min: parseInt(document.getElementById('qualityMin').value),
                        target: parseInt(document.getElementById('qualityTarget').value)
                    },
                    maxColors: parseInt(document.getElementById('maxColors').value),
                    dithering: parseFloat(document.getElementById('dithering').value) / 100
                };

                showMessage('Quantizing image...', 'info');
                const startTime = performance.now();
                
                lastResult = await quantizer.quantizeImageData(originalImageData, options);
                
                const endTime = performance.now();
                const duration = Math.round(endTime - startTime);

                // Display result
                displayQuantizedImage(lastResult);
                displayPalette(lastResult.palette);
                
                // Calculate size information
                const rawKb = Math.round((lastResult.imageData.length / 1024) * 100) / 100;
                const quantizedCanvas = document.getElementById('quantizedCanvas');
                const quantizedPngSizeBytes = await estimatePngSize(quantizedCanvas);
                const quantizedPngKb = Math.round((quantizedPngSizeBytes / 1024) * 100) / 100;
                
                // Calculate original PNG size for comparison
                const originalCanvas = document.getElementById('originalCanvas');
                const originalPngSizeBytes = await estimatePngSize(originalCanvas);
                const originalPngKb = Math.round((originalPngSizeBytes / 1024) * 100) / 100;
                
                const compression = Math.round((1 - (lastResult.paletteLength / 256)) * 100);
                const sizeReduction = Math.round((1 - (quantizedPngSizeBytes / originalPngSizeBytes)) * 100);
                
                document.getElementById('quantizedInfo').innerHTML = `
                    Dimensions: ${lastResult.width} × ${lastResult.height}<br>
                    Colors: ${lastResult.paletteLength}<br>
                    Quality: ${Math.round(lastResult.quality * 100)}%<br>
                    Raw RGBA: ${rawKb} KB<br>
                    PNG encoded: ${quantizedPngKb} KB<br>
                    Size reduction: ${sizeReduction > 0 ? '+' : ''}${sizeReduction}%<br>
                    Time: ${duration}ms
                `;

                showMessage(`Quantization completed in ${duration}ms with ${lastResult.paletteLength} colors`, 'success');
                document.getElementById('downloadBtn').disabled = false;

            } catch (error) {
                showMessage(`Quantization failed: ${error.message}`, 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = 'Quantize Image';
            }
        };

        function displayQuantizedImage(result) {
            const canvas = document.getElementById('quantizedCanvas');
            canvas.width = result.width;
            canvas.height = result.height;
            
            const ctx = canvas.getContext('2d');
            const imageData = new ImageData(
                new Uint8ClampedArray(result.imageData),
                result.width,
                result.height
            );
            
            ctx.putImageData(imageData, 0, 0);
        }

        function displayPalette(palette) {
            const paletteDiv = document.getElementById('palette');
            paletteDiv.innerHTML = '';
            
            palette.forEach((color, index) => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch';
                swatch.style.backgroundColor = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${color[3] / 255})`;
                swatch.title = `Color ${index}: rgba(${color[0]}, ${color[1]}, ${color[2]}, ${color[3]})`;
                paletteDiv.appendChild(swatch);
            });
        }

        window.downloadQuantized = function() {
            if (!lastResult) return;
            
            const canvas = document.getElementById('quantizedCanvas');
            const link = document.createElement('a');
            link.download = 'quantized-image.png';
            link.href = canvas.toDataURL();
            link.click();
        };

        function showMessage(message, type = 'info') {
            const messagesDiv = document.getElementById('messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = type;
            messageDiv.textContent = message;
            messagesDiv.appendChild(messageDiv);
            
            // Remove message after 5 seconds
            setTimeout(() => {
                messageDiv.remove();
            }, 5000);
        }

        // Initialize everything
        updateSliderValues();
        initQuantizer();

        // Make functions available globally
        window.showMessage = showMessage;
    </script>
</body>
</html>